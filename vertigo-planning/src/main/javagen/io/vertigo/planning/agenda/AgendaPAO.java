package io.vertigo.planning.agenda;

import javax.inject.Inject;

import java.util.Optional;
import io.vertigo.core.node.Node;
import io.vertigo.core.lang.Assertion;
import io.vertigo.core.lang.Generated;
import io.vertigo.datamodel.task.TaskManager;
import io.vertigo.datamodel.task.definitions.TaskDefinition;
import io.vertigo.datamodel.task.model.Task;
import io.vertigo.datamodel.task.model.TaskBuilder;
import io.vertigo.datastore.impl.dao.StoreServices;

/**
 * This class is automatically generated.
 * DO NOT EDIT THIS FILE DIRECTLY.
 */
 @Generated
public final class AgendaPAO implements StoreServices {
	private final TaskManager taskManager;

	/**
	 * Constructeur.
	 * @param taskManager Manager des Task
	 */
	@Inject
	public AgendaPAO(final TaskManager taskManager) {
		Assertion.check().isNotNull(taskManager);
		//-----
		this.taskManager = taskManager;
	}

	/**
	 * Creates a taskBuilder.
	 * @param name  the name of the task
	 * @return the builder 
	 */
	private static TaskBuilder createTaskBuilder(final String name) {
		final TaskDefinition taskDefinition = Node.getNode().getDefinitionSpace().resolve(name, TaskDefinition.class);
		return Task.builder(taskDefinition);
	}

	/**
	 * Execute la tache TkCountUnlinkReservationPerXminByAgeId.
	 * @param ageId Long
	 * @param startDate LocalDate
	 * @param endDate LocalDate
	 * @param minuteAgg Integer
	 * @return DtList de PlageHoraireDisplay plageHoraires
	*/
	@io.vertigo.datamodel.task.proxy.TaskAnnotation(
			name = "TkCountUnlinkReservationPerXminByAgeId",
			request = """
			SELECT 
                res.date_Locale as date_Locale,
                (floor(res.minutes_Debut/<%=minuteAgg%>))*<%=minuteAgg%> as minutes_Debut,
                (floor(res.minutes_Debut/<%=minuteAgg%>)+1)*<%=minuteAgg%> as minutes_Fin,
                count(1) as nb_Reserve
            FROM reservation_creneau res
            WHERE res.age_id = #ageId#
                AND res.date_locale BETWEEN #startDate# AND #endDate#
                AND not exists (SELECT 1 FROM tranche_horaire trh 
                                WHERE trh.age_id = res.age_id 
                                    AND res.date_locale = trh.date_locale 
                                    AND res.minutes_debut >= trh.minutes_Debut 
                                    AND res.minutes_debut < trh.minutes_Fin)
            GROUP BY res.date_Locale, floor(res.minutes_Debut/<%=minuteAgg%>);""",
			taskEngineClass = io.vertigo.basics.task.TaskEngineSelect.class)
	@io.vertigo.datamodel.task.proxy.TaskOutput(smartType = "STyDtPlageHoraireDisplay", name = "plageHoraires")
	public io.vertigo.datamodel.structure.model.DtList<io.vertigo.planning.agenda.domain.PlageHoraireDisplay> countUnlinkReservationPerXminByAgeId(@io.vertigo.datamodel.task.proxy.TaskInput(name = "ageId", smartType = "STyPId") final Long ageId, @io.vertigo.datamodel.task.proxy.TaskInput(name = "startDate", smartType = "STyPLocalDate") final java.time.LocalDate startDate, @io.vertigo.datamodel.task.proxy.TaskInput(name = "endDate", smartType = "STyPLocalDate") final java.time.LocalDate endDate, @io.vertigo.datamodel.task.proxy.TaskInput(name = "minuteAgg", smartType = "STyPMinute") final Integer minuteAgg) {
		final Task task = createTaskBuilder("TkCountUnlinkReservationPerXminByAgeId")
				.addValue("ageId", ageId)
				.addValue("startDate", startDate)
				.addValue("endDate", endDate)
				.addValue("minuteAgg", minuteAgg)
				.build();
		return getTaskManager()
				.execute(task)
				.getResult();
	}

	/**
	 * Execute la tache TkCreateCreneauOfPublishedTrancheHoraireByAgeId.
	 * @param ageId Long
	 * @param startDate LocalDate
	 * @param endDate LocalDate
	 * @param instantPublication Instant
	*/
	@io.vertigo.datamodel.task.proxy.TaskAnnotation(
			name = "TkCreateCreneauOfPublishedTrancheHoraireByAgeId",
			request = """
			WITH missing_count AS (
                    SELECT trh.trh_id, (trh.nb_guichet-count(cre.cre_id)) missing_Creneau
                    FROM tranche_horaire trh
                         left join creneau cre on cre.trh_id = trh.trh_id
                    WHERE age_id = #ageId#
                       AND trh.date_locale BETWEEN #startDate# AND #endDate#
                       AND instant_publication = #instantPublication#
                    GROUP BY trh.trh_id, trh.nb_guichet
            )
            INSERT INTO creneau (cre_id, trh_id/*, rec_id*/)
            (SELECT nextval('SEQ_CRENEAU'), trh_id/*, null*/
                           FROM missing_count WHERE missing_Creneau>= 1
            UNION ALL
            SELECT nextval('SEQ_CRENEAU'), trh_id
                           FROM missing_count WHERE missing_Creneau>= 2
            UNION ALL
            SELECT nextval('SEQ_CRENEAU'), trh_id
                           FROM missing_count WHERE missing_Creneau>= 3
            UNION ALL
            SELECT nextval('SEQ_CRENEAU'), trh_id
                           FROM missing_count WHERE missing_Creneau>= 4
            UNION ALL
            SELECT nextval('SEQ_CRENEAU'), trh_id
                           FROM missing_count WHERE missing_Creneau>= 5
            UNION ALL
            SELECT nextval('SEQ_CRENEAU'), trh_id
                           FROM missing_count WHERE missing_Creneau>= 6
            UNION ALL
            SELECT nextval('SEQ_CRENEAU'), trh_id
                           FROM missing_count WHERE missing_Creneau>= 7
            UNION ALL
            SELECT nextval('SEQ_CRENEAU'), trh_id
                           FROM missing_count WHERE missing_Creneau>= 8
            UNION ALL
            SELECT nextval('SEQ_CRENEAU'), trh_id
                           FROM missing_count WHERE missing_Creneau>= 9
            )""",
			taskEngineClass = io.vertigo.basics.task.TaskEngineProc.class)
	public void createCreneauOfPublishedTrancheHoraireByAgeId(@io.vertigo.datamodel.task.proxy.TaskInput(name = "ageId", smartType = "STyPId") final Long ageId, @io.vertigo.datamodel.task.proxy.TaskInput(name = "startDate", smartType = "STyPLocalDate") final java.time.LocalDate startDate, @io.vertigo.datamodel.task.proxy.TaskInput(name = "endDate", smartType = "STyPLocalDate") final java.time.LocalDate endDate, @io.vertigo.datamodel.task.proxy.TaskInput(name = "instantPublication", smartType = "STyPInstant") final java.time.Instant instantPublication) {
		final Task task = createTaskBuilder("TkCreateCreneauOfPublishedTrancheHoraireByAgeId")
				.addValue("ageId", ageId)
				.addValue("startDate", startDate)
				.addValue("endDate", endDate)
				.addValue("instantPublication", instantPublication)
				.build();
		getTaskManager().execute(task);
	}

	/**
	 * Execute la tache TkDeletePlageHoraireCascadeByPlhId.
	 * @param plhId Long
	*/
	@io.vertigo.datamodel.task.proxy.TaskAnnotation(
			name = "TkDeletePlageHoraireCascadeByPlhId",
			request = """
			delete from creneau cre where cre.trh_id in (select trh.trh_id from tranche_horaire trh where trh.plh_id = #plhId#);
        delete from tranche_horaire trh WHERE trh.plh_id = #plhId#;
        delete from plage_horaire plh WHERE plh.plh_id = #plhId#;""",
			taskEngineClass = io.vertigo.basics.task.TaskEngineProc.class)
	public void deletePlageHoraireCascadeByPlhId(@io.vertigo.datamodel.task.proxy.TaskInput(name = "plhId", smartType = "STyPId") final Long plhId) {
		final Task task = createTaskBuilder("TkDeletePlageHoraireCascadeByPlhId")
				.addValue("plhId", plhId)
				.build();
		getTaskManager().execute(task);
	}

	/**
	 * Execute la tache TkGetDateDernierePublicationByAgeId.
	 * @param ageIds List de Long
	 * @param now Instant
	 * @return Option de LocalDate premiereDisponibilite
	*/
	@io.vertigo.datamodel.task.proxy.TaskAnnotation(
			name = "TkGetDateDernierePublicationByAgeId",
			request = """
			SELECT max(trh.date_locale)
          FROM tranche_horaire trh
          WHERE trh.age_id in ( #ageIds.rownum# ) 
            AND trh.date_locale BETWEEN #now#::Date AND (#now#::Date + interval '1 year')
            AND trh.instant_publication <= #now#;""",
			taskEngineClass = io.vertigo.basics.task.TaskEngineSelect.class)
	@io.vertigo.datamodel.task.proxy.TaskOutput(smartType = "STyPLocalDate", name = "premiereDisponibilite")
	public Optional<java.time.LocalDate> getDateDernierePublicationByAgeId(@io.vertigo.datamodel.task.proxy.TaskInput(name = "ageIds", smartType = "STyPId") final java.util.List<Long> ageIds, @io.vertigo.datamodel.task.proxy.TaskInput(name = "now", smartType = "STyPInstant") final java.time.Instant now) {
		final Task task = createTaskBuilder("TkGetDateDernierePublicationByAgeId")
				.addValue("ageIds", ageIds)
				.addValue("now", now)
				.build();
		return Optional.ofNullable((java.time.LocalDate) getTaskManager()
				.execute(task)
				.getResult());
	}

	/**
	 * Execute la tache TkGetDateDisponibleDisplayByAgeId.
	 * @param ageId Long
	 * @param startDate LocalDate
	 * @param endDate LocalDate
	 * @param now Instant
	 * @return DtList de DateDisponibleDisplay plageHoraires
	*/
	@io.vertigo.datamodel.task.proxy.TaskAnnotation(
			name = "TkGetDateDisponibleDisplayByAgeId",
			request = """
			select date_Locale,
                sum(nb_Non_Publie) as nb_Non_Publie,
                sum(nb_Planifie) as nb_Planifie,
                sum(nb_Publie) as nb_Publie,
                sum(nb_Reserve) as nb_Reserve,
                sum(nb_Total) as nb_Total,
                min(instant_Publication) as instant_Publication  
            from (select
                        plh.date_Locale as date_Locale,
                        sum(((trh.instant_Publication is null)::int)) * plh.nb_Guichet as nb_Non_Publie,
                        sum(COALESCE(((trh.instant_Publication > #now#)::int),0)) * plh.nb_Guichet as nb_Planifie,
                        sum(COALESCE(((trh.instant_Publication <= #now#)::int),0)) * plh.nb_Guichet as nb_Publie,
                        sum(COALESCE(res.nb_Reserve,0)) as nb_Reserve,
                        count(1) * plh.nb_Guichet as nb_Total,
                        min(trh.instant_Publication) as instant_Publication              
                   from plage_horaire plh
                        join tranche_horaire trh on trh.plh_id = plh.plh_id
                        left join (
                            SELECT trh.trh_Id as trh_Id,
                                  count(1) as nb_Reserve
                            FROM reservation_creneau res
                                 join tranche_horaire trh on trh.age_id = res.age_id 
                                    AND res.date_locale = trh.date_locale 
                                    AND res.minutes_debut >= trh.minutes_Debut 
                                    AND res.minutes_debut < trh.minutes_Fin
                            WHERE res.age_id = #ageId#
                            GROUP BY trh.trh_id) as res on res.trh_id = trh.trh_id                               
                   WHERE plh.age_id = #ageId#
                   AND plh.date_locale BETWEEN #startDate# AND #endDate#
                   GROUP BY plh.date_Locale, plh.nb_Guichet) as sub
                   GROUP BY date_Locale
                   ORDER BY date_Locale;""",
			taskEngineClass = io.vertigo.basics.task.TaskEngineSelect.class)
	@io.vertigo.datamodel.task.proxy.TaskOutput(smartType = "STyDtDateDisponibleDisplay", name = "plageHoraires")
	public io.vertigo.datamodel.structure.model.DtList<io.vertigo.planning.agenda.domain.DateDisponibleDisplay> getDateDisponibleDisplayByAgeId(@io.vertigo.datamodel.task.proxy.TaskInput(name = "ageId", smartType = "STyPId") final Long ageId, @io.vertigo.datamodel.task.proxy.TaskInput(name = "startDate", smartType = "STyPLocalDate") final java.time.LocalDate startDate, @io.vertigo.datamodel.task.proxy.TaskInput(name = "endDate", smartType = "STyPLocalDate") final java.time.LocalDate endDate, @io.vertigo.datamodel.task.proxy.TaskInput(name = "now", smartType = "STyPInstant") final java.time.Instant now) {
		final Task task = createTaskBuilder("TkGetDateDisponibleDisplayByAgeId")
				.addValue("ageId", ageId)
				.addValue("startDate", startDate)
				.addValue("endDate", endDate)
				.addValue("now", now)
				.build();
		return getTaskManager()
				.execute(task)
				.getResult();
	}

	/**
	 * Execute la tache TkGetDatePremiereDisponibiliteByAgeIds.
	 * @param ageIds List de Long
	 * @param startDate LocalDate
	 * @param endDate LocalDate
	 * @param now Instant
	 * @param displayDayMin LocalDate
	 * @param displayMinutesMin Integer
	 * @return Option de LocalDate premiereDisponibilite
	*/
	@io.vertigo.datamodel.task.proxy.TaskAnnotation(
			name = "TkGetDatePremiereDisponibiliteByAgeIds",
			request = """
			SELECT trh.date_locale
          FROM creneau cre 
          join tranche_horaire trh on cre.trh_id = trh.trh_id 
          WHERE trh.age_id in ( #ageIds.rownum# ) 
            AND trh.date_locale BETWEEN #startDate# AND #endDate#
            AND trh.date_locale >= #displayDayMin#::Date
            AND (trh.date_locale > #displayDayMin#::Date OR trh.minutes_Debut > #displayMinutesMin#)
            AND trh.instant_publication <= #now#
            AND cre.rec_id is null
          order by trh.date_locale
          limit 1;""",
			taskEngineClass = io.vertigo.basics.task.TaskEngineSelect.class)
	@io.vertigo.datamodel.task.proxy.TaskOutput(smartType = "STyPLocalDate", name = "premiereDisponibilite")
	public Optional<java.time.LocalDate> getDatePremiereDisponibiliteByAgeIds(@io.vertigo.datamodel.task.proxy.TaskInput(name = "ageIds", smartType = "STyPId") final java.util.List<Long> ageIds, @io.vertigo.datamodel.task.proxy.TaskInput(name = "startDate", smartType = "STyPLocalDate") final java.time.LocalDate startDate, @io.vertigo.datamodel.task.proxy.TaskInput(name = "endDate", smartType = "STyPLocalDate") final java.time.LocalDate endDate, @io.vertigo.datamodel.task.proxy.TaskInput(name = "now", smartType = "STyPInstant") final java.time.Instant now, @io.vertigo.datamodel.task.proxy.TaskInput(name = "displayDayMin", smartType = "STyPLocalDate") final java.time.LocalDate displayDayMin, @io.vertigo.datamodel.task.proxy.TaskInput(name = "displayMinutesMin", smartType = "STyPHeureMinute") final Integer displayMinutesMin) {
		final Task task = createTaskBuilder("TkGetDatePremiereDisponibiliteByAgeIds")
				.addValue("ageIds", ageIds)
				.addValue("startDate", startDate)
				.addValue("endDate", endDate)
				.addValue("now", now)
				.addValue("displayDayMin", displayDayMin)
				.addValue("displayMinutesMin", displayMinutesMin)
				.build();
		return Optional.ofNullable((java.time.LocalDate) getTaskManager()
				.execute(task)
				.getResult());
	}

	/**
	 * Execute la tache TkGetDefaultPlageHoraireByAgeId.
	 * @param ageId Long
	 * @param startDate LocalDate
	 * @param endDate LocalDate
	 * @return DtList de DefaultPlageHoraire plageHoraires
	*/
	@io.vertigo.datamodel.task.proxy.TaskAnnotation(
			name = "TkGetDefaultPlageHoraireByAgeId",
			request = """
			select 
                1 as jour_de_semaine,
                plh.minutes_Debut as minutes_Debut,
                plh.minutes_Fin as minutes_Fin,
                plh.nb_Guichet as nb_Guichet             
           from plage_horaire plh                                    
           WHERE plh.age_id = #ageId#
           AND plh.date_locale BETWEEN #startDate# AND #endDate#;""",
			taskEngineClass = io.vertigo.basics.task.TaskEngineSelect.class)
	@io.vertigo.datamodel.task.proxy.TaskOutput(smartType = "STyDtDefaultPlageHoraire", name = "plageHoraires")
	public io.vertigo.datamodel.structure.model.DtList<io.vertigo.planning.agenda.domain.DefaultPlageHoraire> getDefaultPlageHoraireByAgeId(@io.vertigo.datamodel.task.proxy.TaskInput(name = "ageId", smartType = "STyPId") final Long ageId, @io.vertigo.datamodel.task.proxy.TaskInput(name = "startDate", smartType = "STyPLocalDate") final java.time.LocalDate startDate, @io.vertigo.datamodel.task.proxy.TaskInput(name = "endDate", smartType = "STyPLocalDate") final java.time.LocalDate endDate) {
		final Task task = createTaskBuilder("TkGetDefaultPlageHoraireByAgeId")
				.addValue("ageId", ageId)
				.addValue("startDate", startDate)
				.addValue("endDate", endDate)
				.build();
		return getTaskManager()
				.execute(task)
				.getResult();
	}

	/**
	 * Execute la tache TkGetFirstLocalDatesFreeOfPlageHorairePerDayOfWeek.
	 * @param ageId Long
	 * @param dateLocaleFromDebut LocalDate
	 * @param dateLocaleFromFin LocalDate
	 * @param dateLocaleToDebut LocalDate
	 * @param dateLocaleToFin LocalDate
	 * @return List de LocalDate firstDatesPerDow
	*/
	@io.vertigo.datamodel.task.proxy.TaskAnnotation(
			name = "TkGetFirstLocalDatesFreeOfPlageHorairePerDayOfWeek",
			request = """
			WITH plhTo as 
                (SELECT distinct plhTo.date_locale, plhFrom.dow, 
                row_number() over (partition by extract(isodow from plhTo.date_locale) order by plhTo.date_locale asc) as date_per_dow_order
                FROM (SELECT distinct age_id, date_locale from plage_horaire 
                        WHERE age_id = #ageId# 
                        AND date_locale between #dateLocaleToDebut# AND #dateLocaleToFin#) plhTo
                    join (SELECT distinct age_id, date_locale, extract(isodow from date_locale) dow --on ne garde que les DayOfWeek de la semaine source
                            FROM plage_horaire plh
                            WHERE age_id = #ageId# 
                              AND date_locale between #dateLocaleFromDebut# AND #dateLocaleFromFin#) as plhFrom 
                    on plhTo.age_id = plhFrom.age_id and plhFrom.dow = extract(isodow from plhTo.date_locale))
            
            SELECT firstFreeDate 
            FROM (
                SELECT firstDate.date_locale+7 firstFreeDate, firstDate.dow, row_number() over (partition by firstDate.dow  order by  firstDate.date_locale asc)
                FROM plhTo as firstDate 
                     left join plhTo as secondDate on firstDate.dow = secondDate.dow --on filtre les dates qui se suivent à 7 jours pour un même jour de la semaine
                        and secondDate.date_per_dow_order = firstDate.date_per_dow_order+1 
                        and secondDate.date_locale = firstDate.date_locale+7
                WHERE secondDate.date_locale is null --on ne retient que ceux qui ont un jour libre
                ) firstDates
            WHERE firstDates.row_number = 1
            order by firstDates.firstFreeDate
           ;""",
			taskEngineClass = io.vertigo.basics.task.TaskEngineSelect.class)
	@io.vertigo.datamodel.task.proxy.TaskOutput(smartType = "STyPLocalDate", name = "firstDatesPerDow")
	public java.util.List<java.time.LocalDate> getFirstLocalDatesFreeOfPlageHorairePerDayOfWeek(@io.vertigo.datamodel.task.proxy.TaskInput(name = "ageId", smartType = "STyPId") final Long ageId, @io.vertigo.datamodel.task.proxy.TaskInput(name = "dateLocaleFromDebut", smartType = "STyPLocalDate") final java.time.LocalDate dateLocaleFromDebut, @io.vertigo.datamodel.task.proxy.TaskInput(name = "dateLocaleFromFin", smartType = "STyPLocalDate") final java.time.LocalDate dateLocaleFromFin, @io.vertigo.datamodel.task.proxy.TaskInput(name = "dateLocaleToDebut", smartType = "STyPLocalDate") final java.time.LocalDate dateLocaleToDebut, @io.vertigo.datamodel.task.proxy.TaskInput(name = "dateLocaleToFin", smartType = "STyPLocalDate") final java.time.LocalDate dateLocaleToFin) {
		final Task task = createTaskBuilder("TkGetFirstLocalDatesFreeOfPlageHorairePerDayOfWeek")
				.addValue("ageId", ageId)
				.addValue("dateLocaleFromDebut", dateLocaleFromDebut)
				.addValue("dateLocaleFromFin", dateLocaleFromFin)
				.addValue("dateLocaleToDebut", dateLocaleToDebut)
				.addValue("dateLocaleToFin", dateLocaleToFin)
				.build();
		return getTaskManager()
				.execute(task)
				.getResult();
	}

	/**
	 * Execute la tache TkGetLinkReservationAfterPublishByAgeId.
	 * @param ageId Long
	 * @param startDate LocalDate
	 * @param endDate LocalDate
	 * @return DtList de AffectionReservation affectionReservation
	*/
	@io.vertigo.datamodel.task.proxy.TaskAnnotation(
			name = "TkGetLinkReservationAfterPublishByAgeId",
			request = """
			SELECT                 
                trh.trh_id as trh_id,
                STRING_AGG( '' || cre.cre_id, ';') as cre_ids,
                rec.rec_id, rec.instant_creation
            FROM  tranche_horaire trh
                join creneau cre on trh.trh_id = cre.trh_id 
                join reservation_creneau rec on trh.age_id = rec.age_id 
                        AND rec.date_locale = trh.date_locale 
                        AND rec.minutes_debut >= trh.minutes_Debut AND rec.minutes_debut < trh.minutes_Fin 
                        AND rec.rec_id not in (select cre2.rec_id from creneau cre2 where cre2.rec_id is not null and cre.trh_id = trh.trh_id  )
            WHERE trh.age_id = #ageId# AND trh.date_locale BETWEEN #startDate# AND #endDate#
                AND rec.age_id = #ageId# AND rec.date_locale BETWEEN #startDate# AND #endDate#
                AND cre.rec_id is null 
            GROUP BY trh.trh_id, rec.rec_id;""",
			taskEngineClass = io.vertigo.basics.task.TaskEngineSelect.class)
	@io.vertigo.datamodel.task.proxy.TaskOutput(smartType = "STyDtAffectionReservation", name = "affectionReservation")
	public io.vertigo.datamodel.structure.model.DtList<io.vertigo.planning.agenda.domain.AffectionReservation> getLinkReservationAfterPublishByAgeId(@io.vertigo.datamodel.task.proxy.TaskInput(name = "ageId", smartType = "STyPId") final Long ageId, @io.vertigo.datamodel.task.proxy.TaskInput(name = "startDate", smartType = "STyPLocalDate") final java.time.LocalDate startDate, @io.vertigo.datamodel.task.proxy.TaskInput(name = "endDate", smartType = "STyPLocalDate") final java.time.LocalDate endDate) {
		final Task task = createTaskBuilder("TkGetLinkReservationAfterPublishByAgeId")
				.addValue("ageId", ageId)
				.addValue("startDate", startDate)
				.addValue("endDate", endDate)
				.build();
		return getTaskManager()
				.execute(task)
				.getResult();
	}

	/**
	 * Execute la tache TkGetPlageHoraireDisplayByAgeId.
	 * @param ageId Long
	 * @param startDate LocalDate
	 * @param endDate LocalDate
	 * @param now Instant
	 * @return DtList de PlageHoraireDisplay plageHoraires
	*/
	@io.vertigo.datamodel.task.proxy.TaskAnnotation(
			name = "TkGetPlageHoraireDisplayByAgeId",
			request = """
			select
                plh.plh_Id as plh_Id,
                plh.date_Locale as date_Locale,
                plh.minutes_Debut as minutes_Debut,
                plh.minutes_Fin as minutes_Fin,
                plh.nb_Guichet as nb_Guichet,
                sum(((trh.instant_Publication is null)::int)) * plh.nb_Guichet as nb_Non_Publie,
                sum(COALESCE(((trh.instant_Publication > #now#)::int),0)) * plh.nb_Guichet as nb_Planifie,
                sum(COALESCE(((trh.instant_Publication <= #now#)::int),0)) * plh.nb_Guichet as nb_Publie,
                count(1) * plh.nb_Guichet as nb_Total,
                min(trh.instant_Publication) as instant_Publication,
                sum(COALESCE(res.nb_Reserve_Non_Publie,0)) as nb_Reserve_Non_Publie,
                sum(COALESCE(res.nb_Reserve,0)) as nb_Reserve                
           from plage_horaire plh
                join tranche_horaire trh on trh.plh_id = plh.plh_id
                left join (
                    SELECT trh.trh_Id as trh_Id,
                          sum (case when trh.instant_Publication <= #now# then 0 else 1 end) as nb_Reserve_Non_Publie,
                          count(1) as nb_Reserve
                    FROM reservation_creneau res
                         join tranche_horaire trh on trh.age_id = res.age_id 
                            AND res.date_locale = trh.date_locale 
                            AND res.minutes_debut >= trh.minutes_Debut 
                            AND res.minutes_debut < trh.minutes_Fin
                    WHERE res.age_id = #ageId#
                     AND res.date_locale BETWEEN #startDate# AND #endDate#
                    GROUP BY trh.trh_id) as res on res.trh_id = trh.trh_id                               
           WHERE plh.age_id = #ageId#
           AND plh.date_locale BETWEEN #startDate# AND #endDate#
           GROUP BY plh.plh_Id, plh.date_Locale, plh.minutes_Debut, plh.minutes_Fin, plh.nb_Guichet;""",
			taskEngineClass = io.vertigo.basics.task.TaskEngineSelect.class)
	@io.vertigo.datamodel.task.proxy.TaskOutput(smartType = "STyDtPlageHoraireDisplay", name = "plageHoraires")
	public io.vertigo.datamodel.structure.model.DtList<io.vertigo.planning.agenda.domain.PlageHoraireDisplay> getPlageHoraireDisplayByAgeId(@io.vertigo.datamodel.task.proxy.TaskInput(name = "ageId", smartType = "STyPId") final Long ageId, @io.vertigo.datamodel.task.proxy.TaskInput(name = "startDate", smartType = "STyPLocalDate") final java.time.LocalDate startDate, @io.vertigo.datamodel.task.proxy.TaskInput(name = "endDate", smartType = "STyPLocalDate") final java.time.LocalDate endDate, @io.vertigo.datamodel.task.proxy.TaskInput(name = "now", smartType = "STyPInstant") final java.time.Instant now) {
		final Task task = createTaskBuilder("TkGetPlageHoraireDisplayByAgeId")
				.addValue("ageId", ageId)
				.addValue("startDate", startDate)
				.addValue("endDate", endDate)
				.addValue("now", now)
				.build();
		return getTaskManager()
				.execute(task)
				.getResult();
	}

	/**
	 * Execute la tache TkGetPlageHoraireDisplayByPlhId.
	 * @param plhId Long
	 * @param now Instant
	 * @return PlageHoraireDisplay plageHoraires
	*/
	@io.vertigo.datamodel.task.proxy.TaskAnnotation(
			name = "TkGetPlageHoraireDisplayByPlhId",
			request = """
			select
                plh.plh_Id as plh_Id,
                plh.date_Locale as date_Locale,
                plh.minutes_Debut as minutes_Debut,
                plh.minutes_Fin as minutes_Fin,
                plh.nb_Guichet as nb_Guichet,
                sum(((trh.instant_Publication is null)::int)) * plh.nb_Guichet as nb_Non_Publie,
                sum(COALESCE(((trh.instant_Publication > #now#)::int),0)) * plh.nb_Guichet as nb_Planifie,
                sum(COALESCE(((trh.instant_Publication <= #now#)::int),0)) * plh.nb_Guichet as nb_Publie,
                count(1) * plh.nb_Guichet as nb_Total,
                min(trh.instant_Publication) as instant_Publication,
                sum(COALESCE(res.nb_Reserve_Non_Publie,0)) as nb_Reserve_Non_Publie,
                sum(COALESCE(res.nb_Reserve,0)) as nb_Reserve
           from plage_horaire plh
                join tranche_horaire trh on trh.plh_id = plh.plh_id
                left join (
                    SELECT trh.trh_Id as trh_Id,
                          sum (case when trh.instant_Publication <= #now# then 0 else 1 end) as nb_Reserve_Non_Publie,
                          count(1) as nb_Reserve
                    FROM reservation_creneau res
                         join tranche_horaire trh on trh.age_id = res.age_id 
                            AND res.date_locale = trh.date_locale 
                            AND res.minutes_debut >= trh.minutes_Debut 
                            AND res.minutes_debut < trh.minutes_Fin
                    WHERE trh.plh_id = #plhId#
                    GROUP BY trh.trh_id) as res on res.trh_id = trh.trh_id                                  
           WHERE plh.plh_id = #plhId#
           GROUP BY plh.plh_Id, plh.date_Locale, plh.minutes_Debut, plh.minutes_Fin, plh.nb_Guichet;""",
			taskEngineClass = io.vertigo.basics.task.TaskEngineSelect.class)
	@io.vertigo.datamodel.task.proxy.TaskOutput(smartType = "STyDtPlageHoraireDisplay", name = "plageHoraires")
	public io.vertigo.planning.agenda.domain.PlageHoraireDisplay getPlageHoraireDisplayByPlhId(@io.vertigo.datamodel.task.proxy.TaskInput(name = "plhId", smartType = "STyPId") final Long plhId, @io.vertigo.datamodel.task.proxy.TaskInput(name = "now", smartType = "STyPInstant") final java.time.Instant now) {
		final Task task = createTaskBuilder("TkGetPlageHoraireDisplayByPlhId")
				.addValue("plhId", plhId)
				.addValue("now", now)
				.build();
		return getTaskManager()
				.execute(task)
				.getResult();
	}

	/**
	 * Execute la tache TkGetPrecedentePublicationByAgeId.
	 * @param ageIds List de Long
	 * @param now Instant
	 * @return Option de PublicationRange publicationRange
	*/
	@io.vertigo.datamodel.task.proxy.TaskAnnotation(
			name = "TkGetPrecedentePublicationByAgeId",
			request = """
			SELECT
            min(date_locale) as date_min,
            max(date_locale) as date_max,
            instant_publication
          FROM tranche_horaire trh1
          WHERE trh1.age_id in ( #ageIds.rownum# ) 
            AND trh1.date_locale BETWEEN (#now#::Date - interval '1 year') AND (#now#::Date + interval '1 year')
            AND trh1.instant_publication IN (
              SELECT max(trh2.instant_publication)
              FROM tranche_horaire trh2
              WHERE trh2.age_id in ( #ageIds.rownum# ) 
                AND trh2.date_locale BETWEEN (#now#::Date - interval '1 year') AND (#now#::Date + interval '1 year')
                AND trh2.instant_publication <= #now#
            )
          GROUP BY trh1.instant_publication;""",
			taskEngineClass = io.vertigo.basics.task.TaskEngineSelect.class)
	@io.vertigo.datamodel.task.proxy.TaskOutput(smartType = "STyDtPublicationRange", name = "publicationRange")
	public Optional<io.vertigo.planning.agenda.domain.PublicationRange> getPrecedentePublicationByAgeId(@io.vertigo.datamodel.task.proxy.TaskInput(name = "ageIds", smartType = "STyPId") final java.util.List<Long> ageIds, @io.vertigo.datamodel.task.proxy.TaskInput(name = "now", smartType = "STyPInstant") final java.time.Instant now) {
		final Task task = createTaskBuilder("TkGetPrecedentePublicationByAgeId")
				.addValue("ageIds", ageIds)
				.addValue("now", now)
				.build();
		return Optional.ofNullable((io.vertigo.planning.agenda.domain.PublicationRange) getTaskManager()
				.execute(task)
				.getResult());
	}

	/**
	 * Execute la tache TkGetProchainePublicationByAgeId.
	 * @param ageIds List de Long
	 * @param now Instant
	 * @return Option de PublicationRange publicationRange
	*/
	@io.vertigo.datamodel.task.proxy.TaskAnnotation(
			name = "TkGetProchainePublicationByAgeId",
			request = """
			SELECT
            min(date_locale) as date_min,
            max(date_locale) as date_max,
            instant_publication
          FROM tranche_horaire trh1
          WHERE trh1.age_id in ( #ageIds.rownum# ) 
            AND trh1.date_locale BETWEEN #now#::Date AND (#now#::Date + interval '1 year')
            AND trh1.instant_publication IN (
              SELECT min(trh2.instant_publication)
              FROM tranche_horaire trh2
              WHERE trh2.age_id in ( #ageIds.rownum# ) 
                AND trh2.date_locale BETWEEN #now#::Date AND (#now#::Date + interval '1 year')
                AND trh2.instant_publication > #now#
            )
          GROUP BY trh1.instant_publication;""",
			taskEngineClass = io.vertigo.basics.task.TaskEngineSelect.class)
	@io.vertigo.datamodel.task.proxy.TaskOutput(smartType = "STyDtPublicationRange", name = "publicationRange")
	public Optional<io.vertigo.planning.agenda.domain.PublicationRange> getProchainePublicationByAgeId(@io.vertigo.datamodel.task.proxy.TaskInput(name = "ageIds", smartType = "STyPId") final java.util.List<Long> ageIds, @io.vertigo.datamodel.task.proxy.TaskInput(name = "now", smartType = "STyPInstant") final java.time.Instant now) {
		final Task task = createTaskBuilder("TkGetProchainePublicationByAgeId")
				.addValue("ageIds", ageIds)
				.addValue("now", now)
				.build();
		return Optional.ofNullable((io.vertigo.planning.agenda.domain.PublicationRange) getTaskManager()
				.execute(task)
				.getResult());
	}

	/**
	 * Execute la tache TkGetTrancheHoraireDisplayByDate.
	 * @param ageId Long
	 * @param dateLocale LocalDate
	 * @param now Instant
	 * @return DtList de TrancheHoraireDisplay trancheHoraires
	*/
	@io.vertigo.datamodel.task.proxy.TaskAnnotation(
			name = "TkGetTrancheHoraireDisplayByDate",
			request = """
			select
                trh.trh_Id as trh_Id,
                trh.date_Locale as date_Locale,
                trh.minutes_Debut as minutes_Debut,
                trh.minutes_Fin as minutes_Fin,
                trh.nb_Guichet as nb_Guichet,
                trh.instant_Publication,
                (CASE 
                    WHEN (trh.instant_Publication is null) THEN 'nonPublie'
                    WHEN (trh.instant_Publication > #now#) THEN 'planifie'
                    WHEN (trh.instant_Publication <= #now#) THEN 'publie'
                 END) as etat_publication,
                COALESCE(res.nb_Reserve_Non_Publie,0) as nb_Reserve_Non_Publie,
                COALESCE(res.nb_Reserve,0) as nb_Reserve 
           from tranche_horaire trh
           left join (
                    SELECT trh.trh_Id as trh_Id,
                          sum (case when trh.instant_Publication <= #now# then 0 else 1 end) as nb_Reserve_Non_Publie,
                          count(1) as nb_Reserve
                    FROM reservation_creneau res
                         join tranche_horaire trh on trh.age_id = res.age_id 
                            AND res.date_locale = trh.date_locale 
                            AND res.minutes_debut >= trh.minutes_Debut 
                            AND res.minutes_debut < trh.minutes_Fin
                    WHERE trh.age_id = #ageId# and trh.date_Locale = #dateLocale#
                    GROUP BY trh.trh_id) as res on res.trh_id = trh.trh_id
           WHERE trh.age_id = #ageId# and trh.date_locale = #dateLocale#
           ORDER BY trh.minutes_Debut;""",
			taskEngineClass = io.vertigo.basics.task.TaskEngineSelect.class)
	@io.vertigo.datamodel.task.proxy.TaskOutput(smartType = "STyDtTrancheHoraireDisplay", name = "trancheHoraires")
	public io.vertigo.datamodel.structure.model.DtList<io.vertigo.planning.agenda.domain.TrancheHoraireDisplay> getTrancheHoraireDisplayByDate(@io.vertigo.datamodel.task.proxy.TaskInput(name = "ageId", smartType = "STyPId") final Long ageId, @io.vertigo.datamodel.task.proxy.TaskInput(name = "dateLocale", smartType = "STyPLocalDate") final java.time.LocalDate dateLocale, @io.vertigo.datamodel.task.proxy.TaskInput(name = "now", smartType = "STyPInstant") final java.time.Instant now) {
		final Task task = createTaskBuilder("TkGetTrancheHoraireDisplayByDate")
				.addValue("ageId", ageId)
				.addValue("dateLocale", dateLocale)
				.addValue("now", now)
				.build();
		return getTaskManager()
				.execute(task)
				.getResult();
	}

	/**
	 * Execute la tache TkGetTrancheHoraireDisplayByPlhId.
	 * @param plhId Long
	 * @param now Instant
	 * @return DtList de TrancheHoraireDisplay trancheHoraires
	*/
	@io.vertigo.datamodel.task.proxy.TaskAnnotation(
			name = "TkGetTrancheHoraireDisplayByPlhId",
			request = """
			select
                trh.trh_Id as trh_Id,
                trh.date_Locale as date_Locale,
                trh.minutes_Debut as minutes_Debut,
                trh.minutes_Fin as minutes_Fin,
                trh.nb_Guichet as nb_Guichet,
                trh.instant_Publication,
                (CASE 
                    WHEN (trh.instant_Publication is null) THEN 'nonPublie'
                    WHEN (trh.instant_Publication > #now#) THEN 'planifie'
                    WHEN (trh.instant_Publication <= #now#) THEN 'publie'
                 END) as etat_publication,
                COALESCE(res.nb_Reserve_Non_Publie,0) as nb_Reserve_Non_Publie,
                COALESCE(res.nb_Reserve,0) as nb_Reserve 
           from tranche_horaire trh
           left join (
                    SELECT trh.trh_Id as trh_Id,
                          sum (case when trh.instant_Publication <= #now# then 0 else 1 end) as nb_Reserve_Non_Publie,
                          count(1) as nb_Reserve
                    FROM reservation_creneau res
                         join tranche_horaire trh on trh.age_id = res.age_id 
                            AND res.date_locale = trh.date_locale 
                            AND res.minutes_debut >= trh.minutes_Debut 
                            AND res.minutes_debut < trh.minutes_Fin
                    WHERE trh.plh_id = #plhId#
                    GROUP BY trh.trh_id) as res on res.trh_id = trh.trh_id
           WHERE trh.plh_id = #plhId#
           ORDER BY trh.minutes_Debut;""",
			taskEngineClass = io.vertigo.basics.task.TaskEngineSelect.class)
	@io.vertigo.datamodel.task.proxy.TaskOutput(smartType = "STyDtTrancheHoraireDisplay", name = "trancheHoraires")
	public io.vertigo.datamodel.structure.model.DtList<io.vertigo.planning.agenda.domain.TrancheHoraireDisplay> getTrancheHoraireDisplayByPlhId(@io.vertigo.datamodel.task.proxy.TaskInput(name = "plhId", smartType = "STyPId") final Long plhId, @io.vertigo.datamodel.task.proxy.TaskInput(name = "now", smartType = "STyPInstant") final java.time.Instant now) {
		final Task task = createTaskBuilder("TkGetTrancheHoraireDisplayByPlhId")
				.addValue("plhId", plhId)
				.addValue("now", now)
				.build();
		return getTaskManager()
				.execute(task)
				.getResult();
	}

	/**
	 * Execute la tache TkLinkCreneauToReservation.
	 * @param affectionReservation DtList de AffectionReservation
	*/
	@io.vertigo.datamodel.task.proxy.TaskAnnotation(
			name = "TkLinkCreneauToReservation",
			request = """
			UPDATE creneau 
        SET rec_Id = #affectionReservation.recId#
        WHERE cre_id = #affectionReservation.creId#;""",
			taskEngineClass = io.vertigo.basics.task.TaskEngineProcBatch.class)
	public void linkCreneauToReservation(@io.vertigo.datamodel.task.proxy.TaskInput(name = "affectionReservation", smartType = "STyDtAffectionReservation") final io.vertigo.datamodel.structure.model.DtList<io.vertigo.planning.agenda.domain.AffectionReservation> affectionReservation) {
		final Task task = createTaskBuilder("TkLinkCreneauToReservation")
				.addValue("affectionReservation", affectionReservation)
				.build();
		getTaskManager().execute(task);
	}

	/**
	 * Execute la tache TkPublishTrancheHoraireByAgeId.
	 * @param ageId Long
	 * @param startDate LocalDate
	 * @param endDate LocalDate
	 * @param now Instant
	 * @param instantPublication Instant
	*/
	@io.vertigo.datamodel.task.proxy.TaskAnnotation(
			name = "TkPublishTrancheHoraireByAgeId",
			request = """
			UPDATE tranche_horaire trh 
            SET instant_publication = #instantPublication#
        WHERE age_id = #ageId#
        AND trh.date_locale BETWEEN #startDate# AND #endDate#
        AND (trh.instant_Publication is null OR trh.instant_Publication > #now#);""",
			taskEngineClass = io.vertigo.basics.task.TaskEngineProc.class)
	public void publishTrancheHoraireByAgeId(@io.vertigo.datamodel.task.proxy.TaskInput(name = "ageId", smartType = "STyPId") final Long ageId, @io.vertigo.datamodel.task.proxy.TaskInput(name = "startDate", smartType = "STyPLocalDate") final java.time.LocalDate startDate, @io.vertigo.datamodel.task.proxy.TaskInput(name = "endDate", smartType = "STyPLocalDate") final java.time.LocalDate endDate, @io.vertigo.datamodel.task.proxy.TaskInput(name = "now", smartType = "STyPInstant") final java.time.Instant now, @io.vertigo.datamodel.task.proxy.TaskInput(name = "instantPublication", smartType = "STyPInstant") final java.time.Instant instantPublication) {
		final Task task = createTaskBuilder("TkPublishTrancheHoraireByAgeId")
				.addValue("ageId", ageId)
				.addValue("startDate", startDate)
				.addValue("endDate", endDate)
				.addValue("now", now)
				.addValue("instantPublication", instantPublication)
				.build();
		getTaskManager().execute(task);
	}

	/**
	 * Execute la tache TkReserverCreneaux.
	 * @param creneaux DtList de Creneau
	 * @return Integer intSqlRowcount
	*/
	@io.vertigo.datamodel.task.proxy.TaskAnnotation(
			name = "TkReserverCreneaux",
			request = """
			UPDATE creneau 
        SET rec_id = #creneaux.0.rec_id#
        WHERE cre_id = #creneaux.0.cre_id# and rec_id is null;""",
			taskEngineClass = io.vertigo.basics.task.TaskEngineProcBatch.class)
	@io.vertigo.datamodel.task.proxy.TaskOutput(smartType = "STyPNombre", name = "intSqlRowcount")
	public Integer reserverCreneaux(@io.vertigo.datamodel.task.proxy.TaskInput(name = "creneaux", smartType = "STyDtCreneau") final io.vertigo.datamodel.structure.model.DtList<io.vertigo.planning.agenda.domain.Creneau> creneaux) {
		final Task task = createTaskBuilder("TkReserverCreneaux")
				.addValue("creneaux", creneaux)
				.build();
		return getTaskManager()
				.execute(task)
				.getResult();
	}

	/**
	 * Execute la tache TkSupprimerReservationsCreneau.
	 * @param recIds List de Long
	*/
	@io.vertigo.datamodel.task.proxy.TaskAnnotation(
			name = "TkSupprimerReservationsCreneau",
			request = """
			UPDATE creneau 
        SET rec_id = null
        WHERE rec_id in (#recIds.rownum#);
        delete from reservation_creneau where rec_id in (#recIds.rownum#);""",
			taskEngineClass = io.vertigo.basics.task.TaskEngineProc.class)
	public void supprimerReservationsCreneau(@io.vertigo.datamodel.task.proxy.TaskInput(name = "recIds", smartType = "STyPId") final java.util.List<Long> recIds) {
		final Task task = createTaskBuilder("TkSupprimerReservationsCreneau")
				.addValue("recIds", recIds)
				.build();
		getTaskManager().execute(task);
	}

	private TaskManager getTaskManager() {
		return taskManager;
	}
}
